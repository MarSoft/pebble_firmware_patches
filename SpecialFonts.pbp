; This patch allows using different colors for different characters

#ifndef codeC
; graphics_draw_text, beginning
82 b0 f0 b5 @ 93 b0 04 46 {
	; was:
	; SUB SP,SP,0x4C
	; MOV R4, R0
	; free to use: R4-R7
	B.W my_gdc
	global cont_gdc
}
; graphics_draw_text, ending
13 b0 @ bd e8 f0 40 02 b0 70 47 {
	;ADD SP,SP,0x4C
	; was:
	;POP.W {R4-R7,LR}
	;ADD SP,SP,8
	;BX LR
	B.W my_gdce
}

; text_layout_render_char proc, ending
05 9b ea 68 30 46 21 46  bd e8 70 40 02 b0 @ ?4 {
	; was: B.W text_render_draw_char
	B.W my1
}

82 b0 2d e9 f0 4f 99 b0 {
	proc text_render_draw_char
}
#endif

{
	global my_gdc

	; save current graphics context values which we'll overwrite into stack
	LDRB R4, [R0, 0x2d] ; stroke color
	PUSH {R4}
	; store current text color in stroke color byte (fixme?)
	LDRB R4, [R0, 0x2f] ; text color
	STRB R4, [R0, 0x2d] ; save it as stroke color

	; reexec..
	SUB SP,SP,0x4C
	MOV R4, R0
	B.W cont_gdc

;--

	ALIGN 4
	global my_gdce
	; restore graphics context
	; here R4 is graphics context, and R1-R3,R5-R7 are free to use
	POP {R1}
	STRB R1, [R4, 0x2d] ; stroke color

	; reexecute
	POP {R4-R7,LR}
	ADD SP,SP,8
	BX LR

;--

	ALIGN 4
	global my1
	; R0: ctx
	; R1: codepoint
	; R2: ?
	; R3: origin pos
#ifdef CodeAc
	PUSH {R1,R4-R7}

	; mapping table based on codepoint
	CMP R1, 0x41 ; A
	BCC default ; <
	CMP R1, 0x7A ; z
	BHI default
	CMP R1, 0x5A ; Z
	BLS uppercase
	CMP R1, 0x61 ; a
	BCC default ; in between
	lowercase:
	SUB R1, 0x20 ; convert to uppercase
	uppercase:
	SUB R1, 0x41 ; A
	ADR R4, table
	LDRB R4, [R4, R1] ; color = table[letter]

	; check for bg color
	LDRB R5, [R0, 0x2e] ; fill color - we suppose it equals to bg. FIXME?
	CMP R5, R4 ; TODO: fuzzy comparsion
	BEQ default ; if new fg == bg then use default fg instead

	B setcolor

	default:
	LDRB R4, [R0, 0x2d] ; load pre-saved default color

	; set that color as font color
	setcolor:
	STRB R4, [R0, 0x2f]

	POP {R1,R4-R7}
	B.W text_render_draw_char

	ALIGN 4
	table:
	; black: c0, red: f0, blue: c3
	db c0 f0 c0 c3 ; abcd
	db f0 c0 c3 f0 ; efgh
	db c3 c3 c3 c0 ; ijkl
	db f0 c3 c3 f0 ; mnop
	db c0 c3 f0 c3 ; qrst
	db f0 c0 c0 f0 ; uvwx
	db f0 c0       ; yz
#else
#ifdef CodeB

	; R0: ctx
	; R1: codepoint
	; R2: ?
	; R3: origin pos
	PUSH {R1,R4-R7}

	; TODO

	POP {R1,R4-R7}
	B.W text_render_draw_char

#else
#ifdef CodeC

	; R0: ctx
	; R1: codepoint
	; R2: ?
	; R3: origin pos
	PUSH {R1,R4-R7}

	; TODO


#ifdef _comment

init {
	prev_bottom = 0;
	prev_width = 0;
}
get_char_meta after {
	have: new_top, new_left, new_width, new_height
	have: prev_bottom, perv_width
	ret_width = new_width ; for now
	if new_top > prev_bottom:
		ret_width = -prev_width ; is it possible?
	prev_width = new_width
	prev_bottom = new_top + new_height ; for next time
	return: new_top, new_left, *ret_width*, new_height
}
draw_char before {
	draw gray rect on new char rect? (but don't overwrite prev char)
	draw white line on lower third of that same rect
}
	; 0. on start: reset prev char top & width
	; 1. draw bg and/or lower line
	; 1a. if curr/prev char is 'q', skip drawing line?
	; FIX: how to avoid overwriting prev char? Maybe check for fg color?
	; 2. when determining char metadata, check prev char;
#endif

	POP {R1,R4-R7}
	B.W text_render_draw_char

#else
Error: please specify desired coding
#endif
#endif
#endif
}


#ifdef _comment

Whenever we need char advance:
1. If this char is not-kernable, continue as always
2. If it is kernable, check *next* char's codepoint
3. If kerning applies, *curr* char advance shall be zero!
4. ...and next char advance should be ideally max(curr_advance, next_advance)
Possible problem: added '-' in wrapped word between kernable letters will be shifted on top of left letter

#endif

#ifdef CodeC
; iterate_line before main loop
0a f1 34 02 06 92 10 46  f1 68 2a 46 @ ?4
{
	; was: BL text_layout_get_char_advance(first char)
	; can use R3
	B.W bef_main_loop
	global bef_main_loop_cont
}
;iterate_line in main loop
06 98 f1 68 cd f8 0c c0  2a 46 @ ?4
{
	; was: BL text_layout_get_char_advance(curr char)
	B.W in_main_loop
	global in_main_loop_cont
}
08 b5 03 68 13 b9 03 48  ?4 80 68 98 47 08 bd {
	proc iterator_next
}
08 b5 43 68 13 b9 03 48  ?4 80 68 98 47 08 bd {
	proc iterator_prev
}
70 b5 0e 46 14 46 05 46 {
	proc text_layout_get_char_advance
}
{
	global bef_main_loop
	ADD R3, SP, 0x2C ; [pciter]
	BL my_get_advance
	B.W bef_main_loop_cont
	ALIGN 4

;--

	global in_main_loop
	ADD R3, SP, 0x2C ; [pciter]
	BL my_get_advance
	B.W in_main_loop_cont
	ALIGN 4

;--

	global my_get_advance
	; R0: text_ctx
	; R1: font
	; R2: curr codepoint
	; R3: pciter
	; R3+sizeof(Iterator): pciterextra
	PUSH {R0-R5,LR}

	; is font kernable?
	;TODO
	;BNE regular

	; is R2 char kernable?
	;TODO get char's kerning height
	;BNE regular
	;MOV R5, [kern height]

	; load next char
	MOV R4, R3 ; save iter
	MOV R0, R4 ; iter
	BL iterator_next
	LDR R2, [R4, 0x28] ; sizeof(iterator)+pciterdata.char_iter_extra.currchardecoded

	; restore pointer
	PUSH {R0-R3}
	MOV R0, R4 ; iter
	BL iterator_prev
	POP {R0-R3}

	; can R2 char kern with prev one?
	;TODO get char's herning height
	;CMP kern_height, R5
	;BLT do_kerning
	; for now do kerning for char%2=0
	EOR R0, R2, 1 ; XOR
	CBZ R0, do_kerning

	regular:
	POP {R0-R5,LR}
	B.W text_layout_get_char_advance

	do_kerning:
	POP {R0-R5,LR}
	MOV R0, 0 ; zero advance
	BX LR
	ALIGN 4

;--

	global get_char_kern_height
	; R0: codepoint
	PUSH {R1-R4,LR}

	CMP R0, 0x41 ; A
	BCC zero
	CMP R0, 0x7A ; z
	BHI zero
	CMP R0, 0x5A ; Z
	BLS upper
	CMP R0, 0x61 ; a
	BCC zero ; in between Z..a
	lower:
	SUB R0, 0x20 ; convert to upper

	upper:
	; now R0 is A..Z; calculate kerning position

	;TODO

	B ret

	zero:
	MOV R0, 0

	ret:
	POP {R1-R4,PC}
}
#endif
