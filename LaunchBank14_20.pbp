; This patch changes behaviour of the Back button
; in watchfaces:
; When you press it from any watchface,
; it will launch app installed in bank 0 (the first bank).
; You may choose which app is installed in bank0
; by uninstalling and reinstalling apps in desired order.
;
; This version works with 2.0.0, any HW version.

; just a simple mask to find named proc
08 4b 10 b5 04 46 18 68 08 e0 {
	proc app_manager_get_bank_info 
}

1f b5 04 46 20 b9 09 48 {
	proc app_manager_launch 
}

37 B5 0D 46 04 46 0D F1 02 01 01 A8 {
	proc time_ms
}

; usage:
; R0 = 1 (loglevel_error)
; R1 = pszFilename
; R2 = nLineNumber
; R3 = pszFormat
08 B4 F0 B5 A6 B0 2B AC {
	proc app_log
}

; This matches some SerialConsole-related proc
; which references memory address used for serial console read buffer.
; We will use this address to store timer value.
08 B5 05 4B 1B 78 13 B9  3E 20 ?4 03 4B
00 22 C3 F8 84 20 08 BD  ?4 @ {
	val counter_ptr
}

; This matches beginning of watchface_button_handler proc.
; We replace "CMP R3, 5 // BEQ ret" with our code:
38 B5 03 78 @ 05 2b 2b d0  00 79 02 28 04 d0 03 28 {
	B.W my_code
	global continue: ; and will return here if we wouldn't like to consume button :)
}

; This is a cmdAppRemove proc
; (from serial console, thus unused in normal scenario)
; which we replace with our continuation to previous proc.
08 B5 ?4 43 1c  0d d0 c0 b2 ?4
20 B1 00 21 ?4  03 48 00 e0 03 48 BD E8
08 40 ?4 08 BD  ?8
; and cmdAppAvailable (partially)
08 B5 ?4 42 1C  07 D0 C0 B2 ?4
02 48 BD E8 08 40
{
	proc my_code
	CMP R3, 5 ; reexecute replaced code
	BEQ retret ; nobody likes R3!=5 :)

	MOV R5, R0 ; save R0 as we want to use it

	; check if this is first or subsequent btn press
	LDR R0, counter
	LDR R4, [R0] ; get old counter value
	MOV R1, 0
	BL time_ms
	LDR R2, counter
	LDR R1, [R2]
	MOV.W R3, 1000
	MUL R1, R3 ; convert seconds to millis
	ADD R1, R0 ; now R1 contains full timestamp

	; check current button
	LDRB R0, [R5,4]
MOV R6, R0
	CBNZ R0, notupdate

	; update counter only if this was Back btn
	STR R1, [R2] ; update counter value

	; check diff
	notupdate:
	SUB R1, R1, R4 ; calculate diff
MOV R7, R1
	MOV.W R3, 500 ; delay in millis
	CMP R1, R3
	BHI cont ; if diff is too large, pass this button to original proc

	; now launch app: get its info -
	; R0 holds button id, which we use as bank id,
	; i.e. launch app from bank 0..3 depending on button
;debug:
MOV R2, R7
MOV R0, 1
ADR R1, filename
ADR R3, in_launch
BL app_log
MOV R0, R6 ; restore current btn in R0
	BL app_manager_get_bank_info
	;jump 1 ret R0 ;
	CBZ R0, ret ; if no such app, just return
	LDR R0, [R0,0xC] ; get app id from bank info
	BL app_manager_launch

	ret: ; terminate proc
;debug:
MOV R2, R7
MOV R0, 1
ADR R1, filename
ADR R3, in_ret
BL app_log
retret:
	db 38 BD ; POP {R3-R5,PC}

	cont: ; return to original proc for it to handle this button
  CBZ R0, ret ; original proc doesn't like Back btn anyway
;debug:
MOV R2, R7
MOV R0, 1
ADR R1, filename
ADR R3, in_cont
BL app_log
	MOV R0, R5 ; restore R0
	B.W continue

	; ---------------------------

	; data block
	ALIGN 4
	counter: ; memory location for click counter. 
	DCD counter_ptr ; this should be a serial console's read buffer
	filename:
	DCB "LaunchBank14_20" 00
	in_cont:
	DCB "in_cont" 00
	in_ret:
	DCB "in_ret_" 00
	in_launch:
	DCB "in_launch" 00
}
