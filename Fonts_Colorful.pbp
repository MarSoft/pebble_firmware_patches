; This patch allows using different colors for different characters

; graphics_draw_text, beginning
82 b0 f0 b5 @ 93 b0 04 46 {
	; was:
	; SUB SP,SP,0x4C
	; MOV R4, R0
	B.W my_gdc
	global cont_gdc
}

; text_layout_render_char proc, ending
05 9b ea 68 30 46 21 46  bd e8 70 40 02 b0 @ ?4 {
	; was: B.W text_render_draw_char
	B.W my1
}

82 b0 2d e9 f0 4f 99 b0 {
	proc text_render_draw_char
}

{
	global my_gdc

	; store current text color in neighbour byte (fixme?)
	LDRB R4, [R0, 0x2f]
	STRB R4, [R0, 0x30]

	; reexec..
	SUB SP,SP,0x4C
	MOV R4, R0
	B.W cont_gdc

;--

	ALIGN 4
	global my1
	; R0: ctx
	; R1: codepoint
	; R2: ?
	; R3: origin pos
	PUSH {R1,R4-R7}

	; mapping table based on codepoint
	CMP R1, 0x41 ; A
	BCC default ; <
	CMP R1, 0x7A ; z
	BHI default
	CMP R1, 0x5A ; Z
	BLS uppercase
	CMP R1, 0x61 ; a
	BCC default ; in between
	lowercase:
	SUB R1, 0x20 ; convert to uppercase
	uppercase:
	SUB R1, 0x41 ; A
	ADR R4, table
	LDRB R4, [R4, R1] ; color = table[letter]

	; check for bg color
	LDRB R5, [R0, 0x2e] ; fill color - we suppose it equals to bg. FIXME?
	CMP R5, R4 ; TODO: fuzzy comparsion
	BEQ default ; if new fg == bg then use default fg instead

	B setcolor

	default:
	LDRB R4, [R0, 0x30] ; load pre-saved default color

	; set that color as font color
	setcolor:
	STRB R4, [R0, 0x2f]

	POP {R1,R4-R7}
	B.W text_render_draw_char

	ALIGN 4
	table:
	; black: c0, red: f0, blue: c3
	db c0 f0 c0 c3 ; abcd
	db f0 c0 c3 f0 ; efgh
	db c3 c3 c3 c0 ; ijkl
	db f0 c3 c3 f0 ; mnop
	db c0 c3 f0 c3 ; qrst
	db f0 c0 c0 f0 ; uvwx
	db f0 c0       ; yz
}
